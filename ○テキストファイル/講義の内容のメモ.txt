●3/26

オブジェクト指向について
オブジェクト→もの、対象物
対照的に、手続き型プログラミング


基本的にはノートどおり
コンストラクタについては、窓口は初期化するイメージ




・インスタンス化、コンストラクタは基本
・カプセル、継承、実装は機能


ひとつのオブジェクトをを表現するときに
２つ要素がある

１つめ・・・性格、属性（年齢、容姿など）Be動詞で表現できる部分
２つめ・・・行動、振る舞い（英語をしゃべる、ギターを弾くなど）一般動詞


クラスの中の
フィールド→Be動詞部分
メソッド→一般動詞部分

上記２つをメンバという

今までの課題の中でフィールドを定義していたのはメインメソッドの中
→ローカル変数という

対比して、フィールドの中にある変数のことをメンバ変数という。

publicなどがつくのはすべてフィールド

必ず両方なければならないわけではない
どちらかのみでも成立はする

メソッドの書き方について
処理を行うためのもの。電卓のようなもの

電卓はボタンを押さないと動かない
ボタンにあたるものを引数（ひきすう）という

電卓の処理としては
内部処理を行うことと、
値を返すこと

返された値のことを戻り値（返り値）という。

上記が基本だが、引数を必要としない場合や
戻り値を返さない場合もある。

・原本クラスとは？
インスタンスの元になるもの。
インスタンスを実行して処理を行う。


Person taro=new Person();
これがインスタンス化。
タローインスタンスの発生。

・司令塔クラス
どのような処理を行うか。
何を代入するか。


taro.name="山田太郎";
ドットは、「～の」という意味。
taroの名前に山田太郎を代入。


メソッドの基本

戻り値の型　メソッド名（引数）{

処理内容
return　;
}

returnがない場合は、戻り値がない処理
戻り値の型→voidになる。「空の」というような意味。



●mainメソッドは特殊。
必ず一番最初に実行される。
戻り値は持たない。
自動的に実行される（メソッドは基本的に呼び出されないと実行されない。）



●コンストラクタについて
生み出された瞬間に値を持っているための準備。
初期化をするための準備。

コンストラクタ名は、そのメソッドを含むクラスと同一。

コンストラクタが完全に一致するものにインスタンスは自分を当てはめて実行される。


いちいち代入しないでも、雛形を決めておけばすっきりと代入ができる。


コンストラクタを1つも定義していない場合
→引数も処理内容もないものがウラで自動的に作成され、実行される。
デフォルトコンストラクタという。
public Person(){}

なので、１つでもコンストラクタを定義する場合には、お約束のようにこれを書いておかないとコンパイルエラーになってしまう。

コンストラクタを複数定義する場合
引数のパターンがちがわないとできない。
どのコンストラクタを使うか1つに決められないとエラー。
パターンは引数の数、データ型、順番

1つのクラスの中に同名のメソッドを複数定義することを、
用語：「オーバーロード」という。多重定義。

●カプセル化

オブジェクトのイメージ
フィールドが真ん中にあって、その周りをメソッドが取り囲んでいる。
フィールドは隠されている。

メソッドは処理だから書き換えにくい。

フィールドは変数なので書き換えが起こりやすく、それに伴うエラーもおきやすい。


雛形はかならずpublicにしておく。
ほかのクラスでインスタンス化できなくなるから。



●ゲッターとセッター
getはほかのクラスから読み取る。
setはほかのクラスに書き込む。

ほかのクラスから、アクセスをさせるためのものなので、
この2つをあわせて「アクセサー」とよんだりもする。

ゲッターセッターを使うときは、フィールド名の先頭を大文字にする。
たとえば。。「userName」というフィールド名であれば
getUserName
となる。もともと大文字だったところはそのまま大文字。

・カプセル化のメリット

読み取りだけ許可、書き込みだけ許可、など分けて作りやすい。
フィールド名を変更しなければならない、などの状況で
作業が簡単で済む。

たとえば・・セッターで、年齢が1000歳とかマイナスなど、明らかにおかしい数値は入力することができないように範囲制限することもできる。
入力チェック（バリデーション）という。
if文で設定する。



●3/27

・継承について
ルーツが同じものは同じ継承を設定しておけば、
あとからおおもとを直せばいっせいに反映される。
手間が省けるという意味よりも、同じルーツのものを
いっせいに扱うため



用語：オーバーライド
親クラスの記述を子クラスで上書きすること


・実装
いつもはclassで書いてたところが「interface」
interfaceはルールづくり。
abstract・・・具体的な処理内容を持たない。抽象メソッド
このシステムにこの機能は必ず必要、というものをリストアップする
メソッド名は機能名。playとかstopとか

インターフェースをひっぱってくるときは、extendsじゃなくて
implementsを使う。
抽象メソッドはすべて処理内容を書かなくてはいけないという、
義務が生じる。

extendsとimplementsを同時に使うこともできる



●import文について

パッケージが違えば、同じ名前のクラスはつくれる
importは、どこのクラスか所在をはっきりさせるためのもの

●3/29

データベースとの接続について
資料は06を参照

Javaがもともと用意しているコネクタクラス（API）
APIの種類
①DriverManager
②Connection
③PreparedStatement
④ResultSet
⑤SQLException

DB
演習で使っているのはsql
DB専用のドライバが必要。jarファイルがそれ。
sqlであればsql専用のものがある。

DBの種類。ほかには・・・オラクルなど

そもそも、jarファイルというのは？
Java Archiveファイルの略
アーカイブファイル
javaのクラスばかりを集めて圧縮している
jarファイルは展開しなくてもそのまま使うことができる

DBに接続することをコネクションを作る、という表現をする
つなげる仕組み全体のことをJDBCという。
Java
Data
Base
Connectivity

1p目
何をしているか
getConnectionするために必要な準備をしている

String urlの書き方
"jdbc://mysql://　ここまでお約束
localhostの部分→サーバー名。今回は自分のPCなのでlocal。
その後・・DB名。ここまでマスト。
その後は任意。
autoreconnect=true　再接続をためすか.など。オプション。

public Connection getConnection*A(){
Connection　　 con　　　=　　　null;
↑データ型　　　↑変数名

Class.forName(driverName);
　　　　　　　　↑引数。ドライバのクラス名を指定している。
引数に指定したドライバがメモリにロードされる。ための部分

con　=　　DriverManager.getConnction(url,user,pasword);
↑変数。出来上がったコネクションを入れるための箱
　　　　　　↑API名。　　　↑getConnectionはメソッド名。一番上に出てくるものとはちがうもの。既存のAPIの既存のメソッド名。　　　　　
				　　　↑必要な情報はすでに変数で入力しているので、変数で指定している。　

//ここは難しいところなので理解は後々


return con;
出来上がったコネクションをかえしている。
ここが処理において一番大事。

上記はすべて、原本クラス。
実際に動かすのはインスタンス。


●try、catch文について
例外処理
プログラムにおける例外（Exception）というのは・・

想定外の出来事、という意味合い≒エラー

予想した動作をしなかった場合の処理
プログラムは組まれたこと以外に対して対応できない。
それに対して処理を定めておく。


・try分の書き方

try{
例外が発生する可能性のある処理

}catch(例外の種類 ｽﾍﾟｰｽ 変数名){
例外が実際起きた場合にどうするかの処理

}


e.printStackTrace();について
例外クラスはすべて持っているメソッド
上の行でeに代入した型のエラー内容を、そのまま出力する

catch文を複数書くときというのは・・・
発生したエラーの種類によって内容を書き換えたいときに使い分ける



●DAOについて
Connectionは道を作るだけ
それに対して処理を行うのはほかのクラス
DAOはAccessなのでアクセスクラス


DBConnector db= new DBConnector();

//上記で作った原本をインスタンス化

Connection con= db.getConnection*A();
//dbのgetConnectionする処理がぜんぶconの箱にいれられた

String sql="select*from test_table where user_name=? and password=?";
//users、passwordが？になっているのは何か特定の値を代入するわけではないため
？のことはプレイスホルダと呼ぶ。場所を保持するだけ。

　　　　　　　　　　　　↓edなし。メソッド名　　　　　　　　　↓上記の""内
PreparedStatement ps=con.prepareStatement(sql);
↑型。preparestatement型。statementはsql文を指している。
あらかじめ用意されたsql文。

ps.setString(1,name);
//1番目のプレイスホルダにnameを代入してください。
ps.setString(2,password);

Result set rs=ps.executeQuery();
　　　　　　　　　↑セレクト文を実行してください


if(rs.next()){
//if文の()内は基本boolean
必ずしも等号不等号は書かれていないが、trueになれば実行する、という大前提がある
実行結果がtrue,falseに置き換わるイメージ

Resultsetは戻り値に矢印が含まれている。初期値では項目名、一番上の行を示している。

ネクストメソッドの働き
１．矢印を一行下にずらす
２．矢印の先にデータがあれば、戻り値trueを返す。
　　なければ（＝該当するデータがない場合は）falseを返す。

つまり、入力されたデータに合致する行があるか上から下まで調べて、
あればtrueを返す。
なければ「該当するデータはありません」

簡単に言うと：該当データがあれば処理をする。


con.close();の意味

クローズメソッド
必要な処理のひとつ。
コネクションは最初に作った道。一連の操作が終わった後で、道を閉じる。
理由：コネクションはメモリ上に作られる。
閉じていないままだとPCを圧迫するので。

DAOの働き。実際の働き部分。
上記部分も原本クラス。
DBConnectorに対しては司令塔クラスだが、この原本もインスタンス化される必要がある。


●testクラス
これが最終的な司令塔クラス。

資料の7p、⑤あたり

selectAllについて

基本は一緒
差分だけ

String sql="select*from test_table";
//allなのでプレイスホルダが必要なくなっている

while(rs.next()){
//ifがwhileになっている。ifだと繰り返しが実行されないため
データがある限り下に下に・・


11p⑬insert


public void insert(int user_id, String name, String password){
//int型のuser_id、Stringのname・・・という引数を3つ指定している。

String sql="insert into test_table values(?,?,?)";
//でた、プレイスホルダ。test_tableにisnert予定。値はあとで。

ps.setInt(1,user_id);
ps.setString(2,name);
ps.setString(3,password);

//ここからがだいぶちがう！
int i=ps.executeUpdate(); //Queryではなくなった。格納する変数もResultSetではなくint型になった。
int iは変更されたデータの件数。

データをを更新するという意味の
executeUpdate();
削除でも更新でも挿入でも、すべてこのメソッドを使用する。


CRUDのなんとなくの役割
create//一番仲間はずれ。そもそもユーザーに関係がない。枠のほうだから
read（select）//2番目仲間はずれ。出力するだけでdbに影響を与えないから。
update
delete


SQL文		メソッド			戻り値
------------------------------------------------------------------------------------------------------------
select		executeQuery()		ResultSet
------------------------------------------------------------------------------------------------------------
insert		executeUpdate()		int型(変更したデータの件数)
update
delete
------------------------------------------------------------------------------------------------------------
上記すべて	execute			なし		



●4/1

Struts２というのは・・フレームワークの１つ。
フレームワークは土台にあたる部分。
どんなサイトでも使うようなものを集約したもの

資料　ログイン認証3時間目から

MVCモデル
モデル　処理　データ、DTOなどのプロジェクト
ビュー　画面
コントローラー　この部分をStruts2がやっている

5pは何度も見直すこと

jspはほとんど画面構成のファイル
jspからID,PWなどがActionにいく
このときの情報をパラメーターという
ActionがDBにアクセスをする

ログイン情報が正しければ・・
「ログイン成功.jsp」
正しくなければ
「ログインエラー.jsp」にとぶ

みたいなしくみ

jsp→アクション→DB→アクション→jsp


DAOやDTOの役割


DTOは贈答箱のようなもの。Actionがjspに返すべき
値を管理している
ただのデータのいれもの。
定義と、ゲッターセッターのみのシンプルな構成。


こういった全体の流れを決めているのが

○web.xml・・・最初の動きを決めている
最上部は、おきまりのコード。
次にウェルカムページの指定。
複数が指定されていてもいいが、上から順番に探して
一番最初に実在したページが表示される。

次に、プロジェクトでstruts2を使用するという宣言
filter-nameとfilter-mappingで、同じstruts2を宣言することで
クラス名とurl-patternが紐づく
/*は、プロジェクト配下すべてという意味。
すべてにstruts2を適応するという宣言をしている。

○struts.xml・・・最初のページが表示された後の流れ
最上部は、おきまりのコード。
strutsタグの中身
constant・・・
package name・・・Actionクラスが含まれるパッケージ名
アクションの数だけ書いていく。


<action name="アクション名" class="パッケージ名からの正式なクラス名">

method=アクションが実行されたときに最初に実行されるメソッド名
	特に理由がなければ決まりきったexecuteを使用する
	普通のクラスで言うメインメソッドのようなもの

その下のリザルトセットは、executeの戻り値についての説明をしている

<result name="success">jsp名</result>
<result name="error">jsp名</result>

一番の基本はjspとアクションファイルのやり取り
そこに付加的にDTO、DAO、DB

○Sタグ（s:）の形式のもの

資料３の１８p参照
jspで定義した名前と完全一致の名前でアクションファイルで指定する。
20p参照
セッター、ゲッターも同じ名前で指定する

これではじめて3つが連動してパラメーターをやり取りできるようになる

throwsの意味(throws SQLException)
例外が発生した気に、そのメソッドの中で処理するのではなく、
呼び出した側に処理を丸投げする

プレイスホルダに代入した情報で帰ってきた戻り値をDTOにつめているのが15p

Actionを作るときの注意
extends AcctionSupport{・・・
struts2の中のActionSupportを使用
SUCCESS、ERRORなどは大文字小文字がファイルごとにずれていても正しく実行されているが
それは継承したファイルの中に
SUCCESS="success";
ERROR="error";
という定義がされているから正しく実行される

定数という。変数と似ているが、変数の場合は上書き可能だが、
定数は一度値が入れられたら上書き不可。
それ以外は変数と同様に使用することができる。

・jspとアクションフォルダの間


value stackとよばれる一時的な箱
action側にセッターをつくると、この小箱の中に
nameやpwの小箱ができる。
アクションやjspで設定するのはゲッター、セッターだけ

たとえば、ログイン後の画面に名前を表示するようなシステムだとしたら
今度はアクションがわにゲッターを用意する必要がある

実際のデータのやり取りはstruts.xml参照？？
value stackが値を保持できるのは一往復まで
jspから来たデータをアクションに、その戻り値をjspに返したらおわり

ではどうしたらいいか？
↓セッション


●セッション
ログイン情報以外にも保持する情報がある
そのときに必要になるのがsession

一往復を超えて保持したい内容を入れておくのがsession
ブラウザ単位で持っている情報

value stackでやり取りが行われているときに、
その後も保持していたい情報はsessionにいれる処理をする

sessionにいれたものは、ブラウザに対して保存される？

どっかから発行されるもののなかにsessionIDというものがあって
それに対してsessionつくってるから
sessionIDかわらないかぎりは情報は保持される

使う場合は・・・
ECサイト初級4時間目の15p参照
アクションクラスにimplements SessionAware

Strutsのルールで、セッションを扱う場合には
Map(String,Object)session,

mapは組み合わせ。連想配列。右側がコンテンツ。
age,25
name,taro
のように。ラベルが左で中身が右のルール。

設定が終わったら
sessionフィールドのセッター、ゲッターを定義する。

アクションクラスから値を渡したい場合はセッター
アクションクラスが値を取得したい場合はゲッター？
ちょっとここらへん確認したい。

16p
sessionにはputを使う
putはmapがもつメソッド
このあたりが値を入れ込む作業
""がついているのは箱名
ついていないのが実値？

値の取り出しは40p
getメソッド
この書き方で取り出されるのは、mapの右側部分。
左側はキー

toStringメソッド

Object型というのはすべての型の親
どんな型のデータでも入れることができる。
String,List,Mapなど・・
いろんな型のものを受け入れるには都合がいいが、
デメリットとしてはいったん格納されたデータは自分の型を忘れてしまう。



18p
getsession
setsession
ここで実際にsessionをつかった値のやり取り

40p
session.get("userName")
ここで取り出したデータをStringで扱いたい場合
今は何型でもないので、データ型を指定する必要がある
それがtoString

●20190412
テーブル結合について質問
結合は最初に行うものではなく1行ずつ行われる
そのときの接合口となるカラムをonで指定する
だから、接合ポイントになるカラムも行ごとに違う値が入っている
テーブル結合って言うよりテーブル呼び出し　だよね

●20190419
セッションを使おうと思ったらアクションの中で
struts2はvalue stackを良く使う
なので通常と同じようにセッターやゲッターを使う？























