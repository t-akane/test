●3/26

オブジェクト指向について
オブジェクト→もの、対象物
対照的に、手続き型プログラミング


基本的にはノートどおり
コンストラクタについては、窓口は初期化するイメージ




・インスタンス化、コンストラクタは基本
・カプセル、継承、実装は機能


ひとつのオブジェクトをを表現するときに
２つ要素がある

１つめ・・・性格、属性（年齢、容姿など）Be動詞で表現できる部分
２つめ・・・行動、振る舞い（英語をしゃべる、ギターを弾くなど）一般動詞


クラスの中の
フィールド→Be動詞部分
メソッド→一般動詞部分

上記２つをメンバという

今までの課題の中でフィールドを定義していたのはメインメソッドの中
→ローカル変数という

対比して、フィールドの中にある変数のことをメンバ変数という。

publicなどがつくのはすべてフィールド

必ず両方なければならないわけではない
どちらかのみでも成立はする

メソッドの書き方について
処理を行うためのもの。電卓のようなもの

電卓はボタンを押さないと動かない
ボタンにあたるものを引数（ひきすう）という

電卓の処理としては
内部処理を行うことと、
値を返すこと

返された値のことを戻り値（返り値）という。

上記が基本だが、引数を必要としない場合や
戻り値を返さない場合もある。

・原本クラスとは？
インスタンスの元になるもの。
インスタンスを実行して処理を行う。


Person taro=new Person();
これがインスタンス化。
タローインスタンスの発生。

・司令塔クラス
どのような処理を行うか。
何を代入するか。


taro.name="山田太郎";
ドットは、「～の」という意味。
taroの名前に山田太郎を代入。


メソッドの基本

戻り値の型　メソッド名（引数）{

処理内容
return　;
}

returnがない場合は、戻り値がない処理
戻り値の型→voidになる。「空の」というような意味。



●mainメソッドは特殊。
必ず一番最初に実行される。
戻り値は持たない。
自動的に実行される（メソッドは基本的に呼び出されないと実行されない。）



●コンストラクタについて
生み出された瞬間に値を持っているための準備。
初期化をするための準備。

コンストラクタ名は、そのメソッドを含むクラスと同一。

コンストラクタが完全に一致するものにインスタンスは自分を当てはめて実行される。


いちいち代入しないでも、雛形を決めておけばすっきりと代入ができる。


コンストラクタを1つも定義していない場合
→引数も処理内容もないものがウラで自動的に作成され、実行される。
デフォルトコンストラクタという。
public Person(){}

なので、１つでもコンストラクタを定義する場合には、お約束のようにこれを書いておかないとコンパイルエラーになってしまう。

コンストラクタを複数定義する場合
引数のパターンがちがわないとできない。
どのコンストラクタを使うか1つに決められないとエラー。
パターンは引数の数、データ型、順番

1つのクラスの中に同名のメソッドを複数定義することを、
用語：「オーバーロード」という。多重定義。

●カプセル化

オブジェクトのイメージ
フィールドが真ん中にあって、その周りをメソッドが取り囲んでいる。
フィールドは隠されている。

メソッドは処理だから書き換えにくい。

フィールドは変数なので書き換えが起こりやすく、それに伴うエラーもおきやすい。


雛形はかならずpublicにしておく。
ほかのクラスでインスタンス化できなくなるから。



●ゲッターとセッター
getはほかのクラスから読み取る。
setはほかのクラスに書き込む。

ほかのクラスから、アクセスをさせるためのものなので、
この2つをあわせて「アクセサー」とよんだりもする。

ゲッターセッターを使うときは、フィールド名の先頭を大文字にする。
たとえば。。「userName」というフィールド名であれば
getUserName
となる。もともと大文字だったところはそのまま大文字。

・カプセル化のメリット

読み取りだけ許可、書き込みだけ許可、など分けて作りやすい。
フィールド名を変更しなければならない、などの状況で
作業が簡単で済む。

たとえば・・セッターで、年齢が1000歳とかマイナスなど、明らかにおかしい数値は入力することができないように範囲制限することもできる。
入力チェック（バリデーション）という。
if文で設定する。



●3/27

・継承について
ルーツが同じものは同じ継承を設定しておけば、
あとからおおもとを直せばいっせいに反映される。
手間が省けるという意味よりも、同じルーツのものを
いっせいに扱うため

疑問
100個あるうち、99個引き継ぎたい対象があって
1個入らない・・みたいなことはできるのか？


用語：オーバーライド
親クラスの記述を子クラスで上書きすること


・実装
いつもはclassで書いてたところが「interface」
interfaceはルールづくり。
abstract・・・具体的な処理内容を持たない。抽象メソッド
このシステムにこの機能は必ず必要、というものをリストアップする
メソッド名は機能名。playとかstopとか

インターフェースをひっぱってくるときは、extendsじゃなくて
implementsを使う。
抽象メソッドはすべて処理内容を書かなくてはいけないという、
義務が生じる。

extendsとimplementsを同時に使うこともできる



●import文について

パッケージが違えば、同じ名前のクラスはつくれる
importは、どこのクラスか所在をはっきりさせるためのもの

●3/29

データベースとの接続について
資料は06を参照

Javaがもともと用意しているコネクタクラス（API）
APIの種類
①DriverManager
②Connection
③PreparedStatement
④ResultSet
⑤SQLException

DB
演習で使っているのはsql
DB専用のドライバが必要。jarファイルがそれ。
sqlであればsql専用のものがある。

DBの種類。ほかには・・・オラクルなど

そもそも、jarファイルというのは？
Java Archiveファイルの略
アーカイブファイル
javaのクラスばかりを集めて圧縮している
jarファイルは展開しなくてもそのまま使うことができる

DBに接続することをコネクションを作る、という表現をする
つなげる仕組み全体のことをJDBCという。
Java
Data
Base
Connectivity

1p目
何をしているか
getConnectionするために必要な準備をしている

Strinf urlの書き方
"jdbc://mysql://　ここまでお約束
localhostの部分→サーバー名。今回は自分のPCなのでlocal。
その後・・DB名。ここまでマスト。
その後は任意。
autoreconnect=true　再接続をためすか.など。オプション。

public Connection getConnection*A(){
Connection　　 con　　　=　　　null;
↑データ型　　　↑変数名

Class.forName(driverName);
　　　　　　　　↑引数。ドライバのクラス名を指定している。
引数に指定したドライバがメモリにロードされる。ための部分

con　=　　DriverManager.getConnction(url,user,pasword);
↑変数。出来上がったコネクションを入れるための箱
　　　　　　↑API名。　　　↑getConnectionはメソッド名。一番上に出てくるものとはちがうもの。既存のAPIの既存のメソッド名。　　　　　
				　　　↑必要な情報はすでに変数で入力しているので、変数で指定している。　

//ここは難しいところなので理解は後々


return con;
出来上がったコネクションをかえしている。
ここが処理において一番大事。

上記はすべて、原本クラス。
実際に動かすのはインスタンス。


●try、catch文について
例外処理
プログラムにおける例外（Exception）というのは・・

想定外の出来事、という意味合い≒エラー

予想した動作をしなかった場合の処理
プログラムは組まれたこと以外に対して対応できない。
それに対して処理を定めておく。


・try分の書き方

try{
例外が発生する可能性のある処理

}catch(例外の種類 ｽﾍﾟｰｽ 変数名){
例外が実際起きた場合にどうするかの処理

}


e.printStackTrace();について
例外クラスはすべて持っているメソッド
上の行でeに代入した型のエラー内容を、そのまま出力する

catch文を複数書くときというのは・・・
発生したエラーの種類によって内容を書き換えたいときに使い分ける



●DAOについて
Connectionは道を作るだけ
それに対して処理を行うのはほかのクラス
DAOはAccessなのでアクセスクラス


DBConnector db= new DBConnector();

//上記で作った原本をインスタンス化

Connection con= db.getConnection*A();
//dbのgetConnectionする処理がぜんぶconの箱にいれられた

String sql="select*from test_table where user_name=? and password=?";
//users、passwordが？になっているのは何か特定の値を代入するわけではないため
？のことはプレイスホルダと呼ぶ。場所を保持するだけ。

　　　　　　　　　　　　↓edなし。メソッド名　　　　　　　　　↓上記の""内
PreparedStatement ps=con.prepareStatement(sql);
↑型。preparestatement型。statementはsql文を指している。
あらかじめ用意されたsql文。

ps.setString(1,name);
//1番目のプレイスホルダにnameを代入してください。
ps.setString(2,password);

Result set re=ps.executeQuery();
　　　　　　　　　↑セレクト文を実行してください


if(rs.next()){
//if文の()内は基本boolean
必ずしも統合不等号は書かれていないが、trueになれば実行する、という大前提がある

Resultsetは戻り値に矢印が含まれている。初期値では項目名、一番上の行を示している。

ネクストメソッドの働き
１．矢印を一行下にずらす
２．矢印の先にデータがあれば、戻り値trueを返す。
　　なければ（＝該当するデータがない場合は）falseを返す。

つまり、入力されたデータに合致する業があるか上から下まで調べて、
あればtrueを返す。
なければ「該当するデータはありません」

簡単に言うと：該当データがあれば処理をする。


con.close();の意味

クローズメソッド
必要な処理のひとつ。
コネクションは最初に作った道。一連の操作が終わった後で、道を閉じる。
理由：コネクションはメモリ上に作られる。
閉じていないままだとPCを圧迫するので。

DAOの働き。実際の働き部分。
上記部分も原本クラス。
DBConnectorに対しては司令塔クラスだが、この原本もインスタンス化される必要がある。


●testクラス
これが最終的な司令塔クラス。

資料の7p、⑤あたり

selectAllについて

基本は一緒
差分だけ

String sql="select*from test_table";
//allなのでプレイスホルダが必要なくなっている

while(rs.next()){
//ifがwhileになっている。ifだと繰り返しが実行されないため
データがある限り下に下に・・


11p⑬insert


public void insert(int user_id, String name, String password){
//int型のuser_id、Stringのname・・・という引数を3つ指定している。

String sql="insert into test_table values(?,?,?)";
//でた、プレイスホルダ。test_tableにisnert予定。値はあとで。

ps.setInt(1,user_id);
ps.setString(2,name);
ps.setString(3,password);

//ここからがだいぶちがう！
int i=ps.executeUpdate(); //Queryではなくなった。格納する変数もResultSetではなくint型になった。
int iは変更されたデータの件数。

データをを更新するという意味の
executeUpdate();
削除でも更新でも挿入でも、すべてこのメソッドを使用する。


CRUDのなんとなくの役割
create//一番仲間はずれ。そもそもユーザーに関係がない。枠のほうだから
read（select）//2番目仲間はずれ。出力するだけでdbに影響を与えないから。
update
delete


SQL文		メソッド		戻り値
------------------------------------------------------
select		executeQuery()		ResultSet
------------------------------------------------------
insert		executeUpdate()		int型(変更したデータの件数)
update
delete
------------------------------------------------------
上記すべて	execute			なし		



























