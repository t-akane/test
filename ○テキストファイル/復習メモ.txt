自習メモ
----------------------------------------------------
どこまでやったか
初級の2回目のこり
----------------------------------------------------
チームラボ
----------------------------------------------------
自分がよくやるミス
・アンダーバーが？になっている
・最初だけ大文字のつもりが2文字なったりしている
・ファイルの置き場所が違う。とくにxmlファイルが変なとこに入ってる
・jspファイルがwebコンテンツの直下になかったりした
・最初に作ったDB名、table名にしていなかった（手本の写経のままで更新できていない）
・ゲッターとかセッターとかの量産系をこぴぺして、正しく書き換えをしていない
・指定するDBの名前をそもそも間違えている
・strutsと実際に作ったクラスを見比べてみる。不要なものがないか、足りないものがないか。
・builtの削除と、プロジェクトのクリーン。
・jspファイルなのに、頭文字を大文字で始めてしまっている。小文字じゃないと。
・jspファイルの中で、javaを使わなきゃいけないのに必要な導入文を書かなかった。
・if文などの条件式の中でのイコールを=だけにしてしまう。==で指定しないとエラー
----------------------------------------------------
●20190402

DAO,DTO,セッターゲッターなどについて

流れ
ユーザー情報の入力がフロントで行われる
↓
アクションクラスで、送られた情報を受け取り、
メソッドでDBに問い合わせる。
↓
DAOで、DBの検索処理と検索結果がかえされる。
↓
DAOは、必要な情報をDTOクラスに格納してActionクラスに渡す。
↓
ActionクラスはDTOから受け取った情報を処理し、フロントにかえす。
↓
ログイン完了


DTOは貸し出し屋じゃなくて、いっかい受け取って自分で動いて、その値をまたアクションに返す。
アクション→DAO→DTO→アクション

●20190403
@overrideについて
とは・・・スーパークラスのメソッドをサブクラスにおいて同じメソッド名で定義しなおす
お約束
メソッド名を同じにする
引数は同じ数、同じ順番
superを使えば、親クラスで使っていたメソッドを変更せずにそのまま使用することも可能

confirm　たしかめる
プログラミングにおいては・・
確認ダイアログボックスを出すのに良く使う。

メソッドとして
引数に設定した文字列をダイアログに表示する
変数を使用する場合は
押せるボタンはOK、キャンセルで固定みたい。
そしてボタンを押したときに、戻り値としてtrue/flaseを返す。
OK・・true
キャンセル・・false
コンソールを使った条件分岐

throwsの意味
メソッド内で冷害が発生した場合、自分の中でcatchするのではなく、
呼ばれる側に例外処理を投げる

普通はtrycatch文で例外処理を行う

ゲッターセッター
順不同
ここだけじゃなくて全てで順不同
PC後に直されるときに全部読み込まれるから
オブジェクト指向だからそもそも順番はあんまり関係ないのかな

こぴぺするときに気をつけること
頭文字大文字の件と
int、Stringを正しく配置すること

ゲット、セットするときはもともとの変数の形を頭文字小文字にしなきゃ。
大文字にするとうまくゲットセットできないから

○連想配列について
そもそも・・・
変数は1つの値しかいれられないが、配列を使うと複数入れることができる！
みかん箱に好きな名前をつけられるみかん箱の集まり
一つの箱は変数、変数の箱にも名前を書くところがある
添え字・・ナンバリング。０からはじまる。
この添え字の部分を好きな名前に変えられるというのがMAP。

目的：
データをまとめて管理することができる
ソースコードを効率よく書ける（？）
メンテナンス製に優れる（？）

たとえば・・
都道府県を出力するという。
変数に入れるのに４７
プリントメソッドに４７かかる

配列は、格納さえすればあとは数行で同じことができる

ﾏｯﾌﾟについて
キーの重複は許されない
putで格納する
getで値を取り出す

ﾏｯﾌﾟのキー全てを取得するにはKEYSETメソッド
ﾏｯﾌﾟの値を全て取得するにはvaluesメソッド
どちらもSet型で値が返される。
記述の仕方は拡張for文になる？？
ここはちがうかも。言語違うと違うのかもしれない

ペアを全て取得する場合
Map.Entryのインターフェース
これもset型でかえってくる

●20190404
Integer整数
parseIntとは、文字列を整数に変換するJavaScriptのグローバル関数です。

文字列を数値に変換している

trとtdについて
trは行の始まり
tdはセル
trで行を宣言したあとにtdで区切ってセルを作っていく

●20190405
役割を書き出そう。
INSERTとか、DBとのやりとりしてるところはっきりさせる

アクション

DAO
DBにINSERTとか、やり取り系もここ

DTO
ゲッターセッター

●Stringについて
ただ単に文字列を保持するものではない。
基本データ型（プリミティブ型。intとか）には含まれていない。
なぜか。Stringはクラス型変数だから。
クラス型というのはクラスでそのオブジェクトについて定義することで使えるようになる。

●20190408
ﾏｯﾌﾟについて
2つの要素を関連付けること

●20190415
拡張for文　ちょっとややこ
配列を一通り全部やる場合便利？
特定の場合でよりコンパクトに記述できる

データ型[]配列名={"a","b","c"};
    for(データ型 変数名:配列名){
繰り返し処理したい内容;
} 

・キャスト
System.out.print((int)3.2);     //結果は3
()の中で型の変換を明示的に行う。強制的。
データが欠損するためあまり使用しないらしい。（0.2がなくなった）

・文字列、数値の変換
文字列→数値
Integer.parseInt(str)
Integer.valueOf(str)
など

数値→文字列
number.toString()
String.valueOf(number)
など

・メソッドを複数使う場合
public static int ***(a,b){
return 
}
returnしているので、戻り値がこのメソッド名になりかわる。
そう思うと変数名とメソッド名はあまり違いがないのかもしれない。
どちらも箱名で、その中に処理があるかないか
→じゃなくて、メソッド名は変数名じゃないから、変数として使いたければ
変数としての定義を別で行わなきゃいけないの？
学習箇所：メソッドを組み合わせよう

・真偽値を返す
isEven は偶数だったらtrue、奇数だったらfalse

・他のクラスのメソッドを実行する
クラス名.メソッド名();

変数名、メソッド名などは頭文字が小文字だが
クラス名は頭文字大文字　ファイル名も同一にする

mainメソッドをも作らすしか実行されない。
他のクラスはmainメソッドの中に呼び出して使う

外部ライブラリ
他人が作ったクラスを使うことで効率的にプログラミング
import不要なもの
よく使うものはimportしなくても大丈夫
java.lang.クラス名
は全て自動でインポート済み

インスタンスは実体という意味
インスタンスメソッド
public　戻り値の型　メソッド名()
インスタンスメソッドは、インスタンスのメソッドです。
クラスに定義していても、実際は書くインスタンスに属するという意識を持ちましょう。

インスタンスフィールドには、「インスタンス名.フィールド名」でアクセス

thisはクラス内のメソッドの定義おなかでのみ利用できる
メソッドが呼ばれたときにそのメソッドを呼び出しているインスタンスに置き換えられる

コンストラクタは、自動的に実行される特別なメソッド
ルールがある
１．クラス名と同じコンストラクタ名にする。（頭文字も大文字）
２．戻り値は書かない。voidも書かない。

this.変数名＝フィールド名；
はおまじないのように全て書かないと、正しく代入されない
見た目的には
this.name=name;
的なやつ

他のメソッドを呼び出すメソッド
this.でインスタンスを指定する

インスタンスフィールドと暮らすフィールドの違い
全てのインスタンスに関係あるか、共通させていいか
いくつインスタンスを作ったか　とかはstatic　
クラス固有のものにはstatic

今までthis.でやっていたところがstaticだとクラス名.になる

クラスに属するメソッドもある
クラスメソッドの定義の仕方
public static 戻り値の型　メソッド名(){}
staticをつけるかつけないかの違い

呼び出し方
クラス名.メソッド名()


this()
コンストラクタから他のコンストラクタを呼ぶことができる
コンストラクタの中でコンストラクタすればいいだけだけど、
データ型は抜かす必要がある

メソッド名を他で使用したい場合はabc()など、カッコもかいて
実行させる必要がある。それか、変数として定義するなど。

最初は定石
フィールドはprivate
メソッドはpublic

ゲッターセッターがやっぱりようわからない・・
ゲッター
getされるもとのほうでgetメソッドを記述
getしたいほうでは、インスタンス名.getメソッドを記述

ゲッターセッターは、原本を書き換えないままで
クラスで記述されていることを実行するためのもの

・セッターの書き方
public void setMiddleName(String middleName){
this.middleName=middleName;
}

●20190416
ゲッターセッターをやっぱりちゃんと

ゲッﾀｰ
ゲットしたいほうのクラスでやること
person.getMiddleName()
クラス名.getメソッド名で取得できる

ゲットされる元のほうでやること
public String getMiddleName(){
return this.middleName;
}

コンストラクタを使用するときはnewしなくてもいいのか
→newする。インスタンスなんだからnewしないわけない。

thisも混乱する
thisをつけると、クラスで宣言した変数を表示する。（フィールドのほう）
thisがないとメソッドで宣言した変数（ローカル変数）を表示する。
this.はfield.と思っておく。

引数のデータ型がいるときと要らないときは何が違うのか

●20190417
継承したメソッド
子クラスのほうで同じメソッド名で上書きすることも可能
ひとつだけ記述を追加したい場合などは
その足したいものを記述してから、
super.メソッド名();で親に記述してあるメソッドは呼び出せる

サブクラスでコンストラクタを定義するときの木間s利
今ストらkつあの先頭でスーパークラスのコンストラクタを呼び出さなければならない
super()　を使う

abstract　抽象メソッド
必ずメソッドを書かなければならないが、共通メソッドじゃないから枠組みだけ用意
オーバーライドされていないとエラーになる

クラス型のフィールド??
private Person owner;
　　　　　↑ここにクラス名

クラス「型」ってなに
int String voidなどがはいっていたところにクラス名を記述している
car.getOwner().printData();　をメインクラスで実行するということは
vehicleに記述しておいたPerson型のgetOwnerメソッドをcarも継承しているわけで
carの中にある継承されたgetOwnerをするわけで


setで

car.setOnwer(person1);　としていて
メインクラスの一番上でPersonのインスタンス化で
Person person1しているから、コンストラクタにそれが代入されていて

buyメソッドからは後回しにして、
ちょっと復習する

java フィールドで変数を宣言 する しない　違い
ローカル変数の有効範囲(スコープ)としてはメソッド内だけなので、他のメソッドから別のメソッドのローカル変数にアクセスすることはできませんし、メソッドを抜けるとそのローカル変数は消滅します。

有効期限の違い
同じクラスのほかのメソッドや、他のクラスから使いたければフィールド
そのメソッドだけの使い捨てだったらローカル変数でいい
https://bituse.info/java/14
ローカル変数は
そのローカル変数が宣言された｛｝ブロック内の命令文が
すべて実行されると
そのローカル変数に格納された値とともに
コンピュータのメモリから消えてしまいます。

フィールド変数を指定しないで、ローカル変数の間で値をやり取りする場合
コンストラクタで値を渡している
変数の名前は、メソッドの中で整合性が取れていればいい
同じクラス内のメソッド間の変数の受け渡しはほとんどコンストラクタなのかもしれない
    for (int i = 0; i < n; i++) {
      System.out.println(i +1+ "人目");
      が、

    for (int i = 1; i < n; i++) {
      System.out.println(i + "人目");
      
だとだめなのはなぜ


●0419
クラス型のフィールドを引き続き
たとえば
public Person owner;
本来だったらStringとかが入っているところにクラス名を記述することで
クラス型のフィールドの出来上がり
はわかったけど、なんのために？どうやって使うの？
クラス型変数をするときはゲッターとセッターを用意しておく
やり方はこれまでと変わらないが、ゲッターセッターにおいても戻り地の型や仮引数の型はPersonになる
public Person getOwner(){
return this.owner;
}
public void setOwner(Person owner){
this.owner=owner;
}

●0423
クラスの間で値をやり取りするやり方って何があるんだろう
１．インスタンス化
メインメソッドに呼び出して使う。
インスタンス化される元のほうにはフィールドと、ゲッターセッ
ターとか

クラス名をそのまま引っ張ってきてコンストラクタとして値のセットだけ行うようなものもあれば
パブリックボイドして、メソッドとして定義しながらコンストラクタの構造を持っているものもある

Vehicleの絵集においては、メインクラスから乗り物クラスへの値
の受け渡しはほとんどコンストラクタ

SysoでCtr+スペースで一瞬で出せる

